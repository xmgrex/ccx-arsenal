# Domain Layer Rules

## Layer Purpose

Define business entities, Value Objects, and domain logic in the innermost layer with zero external dependencies.

## ALLOWED

- Pure Dart implementation
- Freezed + JsonSerializable
- Value Objects (Money, Email, UserId, etc.)
- Encapsulated business rules

## FORBIDDEN

- `package:flutter/` imports
- `package:flutter_riverpod/` imports
- `package:cloud_firestore/` imports (direct SDK reference)
- Any external dependencies

Domain layer is the innermost layer and has no external dependencies.

## Freezed Entity Pattern

```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'project.freezed.dart';
part 'project.g.dart';

@freezed
class Project with _$Project {
  const factory Project({
    required String id,
    required String title,
    required String description,
    required String clientId,
    required int budgetMin,
    required int budgetMax,
    required ProjectStatus status,
    required DateTime createdAt,
    DateTime? updatedAt,
  }) = _Project;

  factory Project.fromJson(Map<String, dynamic> json) =>
      _$ProjectFromJson(json);
}
```

## Sealed Class (Union Type) Pattern

```dart
@freezed
sealed class ProjectStatus with _$ProjectStatus {
  const factory ProjectStatus.draft() = ProjectStatusDraft;
  const factory ProjectStatus.published() = ProjectStatusPublished;
  const factory ProjectStatus.closed() = ProjectStatusClosed;
  const factory ProjectStatus.completed() = ProjectStatusCompleted;
}
```

## Value Object Pattern

```dart
@freezed
class Money with _$Money {
  const Money._();  // Private constructor for methods

  const factory Money({
    required int amount, // Integer representation (e.g., cents, yen)
  }) = _Money;

  factory Money.fromJson(Map<String, dynamic> json) =>
      _$MoneyFromJson(json);

  // Encapsulate business logic
  String get formatted => '${amount.toString().replaceAllMapped(
    RegExp(r'(\d{1,3})(?=(\d{3})+(?!\d))'),
    (Match m) => '${m[1]},',
  )}';

  Money operator +(Money other) => Money(amount: amount + other.amount);
  Money operator -(Money other) => Money(amount: amount - other.amount);
  bool operator <(Money other) => amount < other.amount;
  bool operator >(Money other) => amount > other.amount;
}
```

## Timestamp Converter (for Firestore)

```dart
class TimestampConverter implements JsonConverter<DateTime, Timestamp> {
  const TimestampConverter();

  @override
  DateTime fromJson(Timestamp timestamp) => timestamp.toDate();

  @override
  Timestamp toJson(DateTime date) => Timestamp.fromDate(date);
}

// Usage
@freezed
class Project with _$Project {
  const factory Project({
    @TimestampConverter() required DateTime createdAt,
    @TimestampConverter() DateTime? updatedAt,
  }) = _Project;
}
```

## Data Conventions

| Type | Convention |
|------|------------|
| **Money** | Integer representation, use `Money` Value Object |
| **DateTime** | Store as UTC in backend, use `TimestampConverter` for Firestore |
| **ID** | String type, UUID or auto-generated by backend |

## Compliance Checklist

Before submitting domain code, verify:

1. [ ] Using `@freezed` annotation
2. [ ] `part` declarations are correct (`*.freezed.dart`, `*.g.dart`)
3. [ ] `fromJson` factory is defined
4. [ ] No external dependencies (Flutter, Firebase, Riverpod)
5. [ ] Business logic is encapsulated in Value Objects
6. [ ] `explicit_to_json: true` is set in build.yaml

## Code Generation

```bash
dart run build_runner build --delete-conflicting-outputs
```

## Verification

```bash
# Check for forbidden imports (must return empty)
grep -r "package:flutter" lib/features/*/domain/
grep -r "riverpod" lib/features/*/domain/
grep -r "cloud_firestore" lib/features/*/domain/
```
